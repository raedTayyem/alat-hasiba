{"ast":null,"code":"import _classCallCheck from \"/home/raed/Desktop/Alat Hasibah/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/raed/Desktop/Alat Hasibah/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/raed/Desktop/Alat Hasibah/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/raed/Desktop/Alat Hasibah/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { escape } from '../../utils/string.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { toSymbol } from '../../utils/latex.js';\nvar name = 'SymbolNode';\nvar dependencies = ['math', '?Unit', 'Node'];\nexport var createSymbolNode = /* #__PURE__ */factory(name, dependencies, function (_ref) {\n  var math = _ref.math,\n    Unit = _ref.Unit,\n    Node = _ref.Node;\n  /**\n   * Check whether some name is a valueless unit like \"inch\".\n   * @param {string} name\n   * @return {boolean}\n   */\n  function isValuelessUnit(name) {\n    return Unit ? Unit.isValuelessUnit(name) : false;\n  }\n  var SymbolNode = /*#__PURE__*/function (_Node) {\n    _inherits(SymbolNode, _Node);\n    var _super = _createSuper(SymbolNode);\n    /**\n     * @constructor SymbolNode\n     * @extends {Node}\n     * A symbol node can hold and resolve a symbol\n     * @param {string} name\n     * @extends {Node}\n     */\n    function SymbolNode(name) {\n      var _this;\n      _classCallCheck(this, SymbolNode);\n      _this = _super.call(this);\n      // validate input\n      if (typeof name !== 'string') {\n        throw new TypeError('String expected for parameter \"name\"');\n      }\n      _this.name = name;\n      return _this;\n    }\n    _createClass(SymbolNode, [{\n      key: \"type\",\n      get: function get() {\n        return 'SymbolNode';\n      }\n    }, {\n      key: \"isSymbolNode\",\n      get: function get() {\n        return true;\n      }\n\n      /**\n       * Compile a node into a JavaScript function.\n       * This basically pre-calculates as much as possible and only leaves open\n       * calculations which depend on a dynamic scope with variables.\n       * @param {Object} math     Math.js namespace with functions and constants.\n       * @param {Object} argNames An object with argument names as key and `true`\n       *                          as value. Used in the SymbolNode to optimize\n       *                          for arguments from user assigned functions\n       *                          (see FunctionAssignmentNode) or special symbols\n       *                          like `end` (see IndexNode).\n       * @return {function} Returns a function which can be called like:\n       *                        evalNode(scope: Object, args: Object, context: *)\n       */\n    }, {\n      key: \"_compile\",\n      value: function _compile(math, argNames) {\n        var name = this.name;\n        if (argNames[name] === true) {\n          // this is a FunctionAssignment argument\n          // (like an x when inside the expression of a function\n          // assignment `f(x) = ...`)\n          return function (scope, args, context) {\n            return args[name];\n          };\n        } else if (name in math) {\n          return function (scope, args, context) {\n            return scope.has(name) ? scope.get(name) : getSafeProperty(math, name);\n          };\n        } else {\n          var isUnit = isValuelessUnit(name);\n          return function (scope, args, context) {\n            return scope.has(name) ? scope.get(name) : isUnit ? new Unit(null, name) : SymbolNode.onUndefinedSymbol(name);\n          };\n        }\n      }\n\n      /**\n       * Execute a callback for each of the child nodes of this node\n       * @param {function(child: Node, path: string, parent: Node)} callback\n       */\n    }, {\n      key: \"forEach\",\n      value: function forEach(callback) {\n        // nothing to do, we don't have any children\n      }\n\n      /**\n       * Create a new SymbolNode with children produced by the given callback.\n       * Trivial since a SymbolNode has no children\n       * @param {function(child: Node, path: string, parent: Node) : Node} callback\n       * @returns {SymbolNode} Returns a clone of the node\n       */\n    }, {\n      key: \"map\",\n      value: function map(callback) {\n        return this.clone();\n      }\n\n      /**\n       * Throws an error 'Undefined symbol {name}'\n       * @param {string} name\n       */\n    }, {\n      key: \"clone\",\n      value:\n      /**\n       * Create a clone of this node, a shallow copy\n       * @return {SymbolNode}\n       */\n      function clone() {\n        return new SymbolNode(this.name);\n      }\n\n      /**\n       * Get string representation\n       * @param {Object} options\n       * @return {string} str\n       * @override\n       */\n    }, {\n      key: \"_toString\",\n      value: function _toString(options) {\n        return this.name;\n      }\n\n      /**\n       * Get HTML representation\n       * @param {Object} options\n       * @return {string} str\n       * @override\n       */\n    }, {\n      key: \"toHTML\",\n      value: function toHTML(options) {\n        var name = escape(this.name);\n        if (name === 'true' || name === 'false') {\n          return '<span class=\"math-symbol math-boolean\">' + name + '</span>';\n        } else if (name === 'i') {\n          return '<span class=\"math-symbol math-imaginary-symbol\">' + name + '</span>';\n        } else if (name === 'Infinity') {\n          return '<span class=\"math-symbol math-infinity-symbol\">' + name + '</span>';\n        } else if (name === 'NaN') {\n          return '<span class=\"math-symbol math-nan-symbol\">' + name + '</span>';\n        } else if (name === 'null') {\n          return '<span class=\"math-symbol math-null-symbol\">' + name + '</span>';\n        } else if (name === 'undefined') {\n          return '<span class=\"math-symbol math-undefined-symbol\">' + name + '</span>';\n        }\n        return '<span class=\"math-symbol\">' + name + '</span>';\n      }\n\n      /**\n       * Get a JSON representation of the node\n       * @returns {Object}\n       */\n    }, {\n      key: \"toJSON\",\n      value: function toJSON() {\n        return {\n          mathjs: 'SymbolNode',\n          name: this.name\n        };\n      }\n\n      /**\n       * Instantiate a SymbolNode from its JSON representation\n       * @param {Object} json  An object structured like\n       *                       `{\"mathjs\": \"SymbolNode\", name: \"x\"}`,\n       *                       where mathjs is optional\n       * @returns {SymbolNode}\n       */\n    }, {\n      key: \"_toTex\",\n      value:\n      /**\n       * Get LaTeX representation\n       * @param {Object} options\n       * @return {string} str\n       * @override\n       */\n      function _toTex(options) {\n        var isUnit = false;\n        if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {\n          isUnit = true;\n        }\n        var symbol = toSymbol(this.name, isUnit);\n        if (symbol[0] === '\\\\') {\n          // no space needed if the symbol starts with '\\'\n          return symbol;\n        }\n        // the space prevents symbols from breaking stuff like '\\cdot'\n        // if it's written right before the symbol\n        return ' ' + symbol;\n      }\n    }], [{\n      key: \"onUndefinedSymbol\",\n      value: function onUndefinedSymbol(name) {\n        throw new Error('Undefined symbol ' + name);\n      }\n    }, {\n      key: \"fromJSON\",\n      value: function fromJSON(json) {\n        return new SymbolNode(json.name);\n      }\n    }]);\n    return SymbolNode;\n  }(Node);\n  return SymbolNode;\n}, {\n  isClass: true,\n  isNode: true\n});","map":{"version":3,"names":["escape","getSafeProperty","factory","toSymbol","name","dependencies","createSymbolNode","_ref","math","Unit","Node","isValuelessUnit","SymbolNode","TypeError","argNames","scope","args","context","has","get","isUnit","onUndefinedSymbol","callback","clone","options","mathjs","symbol","Error","json","isClass","isNode"],"sources":["/home/raed/Desktop/Alat Hasibah/node_modules/mathjs/lib/esm/expression/node/SymbolNode.js"],"sourcesContent":["import { escape } from '../../utils/string.js';\nimport { getSafeProperty } from '../../utils/customs.js';\nimport { factory } from '../../utils/factory.js';\nimport { toSymbol } from '../../utils/latex.js';\nvar name = 'SymbolNode';\nvar dependencies = ['math', '?Unit', 'Node'];\nexport var createSymbolNode = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    math,\n    Unit,\n    Node\n  } = _ref;\n  /**\n   * Check whether some name is a valueless unit like \"inch\".\n   * @param {string} name\n   * @return {boolean}\n   */\n  function isValuelessUnit(name) {\n    return Unit ? Unit.isValuelessUnit(name) : false;\n  }\n  class SymbolNode extends Node {\n    /**\n     * @constructor SymbolNode\n     * @extends {Node}\n     * A symbol node can hold and resolve a symbol\n     * @param {string} name\n     * @extends {Node}\n     */\n    constructor(name) {\n      super();\n      // validate input\n      if (typeof name !== 'string') {\n        throw new TypeError('String expected for parameter \"name\"');\n      }\n      this.name = name;\n    }\n    get type() {\n      return 'SymbolNode';\n    }\n    get isSymbolNode() {\n      return true;\n    }\n\n    /**\n     * Compile a node into a JavaScript function.\n     * This basically pre-calculates as much as possible and only leaves open\n     * calculations which depend on a dynamic scope with variables.\n     * @param {Object} math     Math.js namespace with functions and constants.\n     * @param {Object} argNames An object with argument names as key and `true`\n     *                          as value. Used in the SymbolNode to optimize\n     *                          for arguments from user assigned functions\n     *                          (see FunctionAssignmentNode) or special symbols\n     *                          like `end` (see IndexNode).\n     * @return {function} Returns a function which can be called like:\n     *                        evalNode(scope: Object, args: Object, context: *)\n     */\n    _compile(math, argNames) {\n      var name = this.name;\n      if (argNames[name] === true) {\n        // this is a FunctionAssignment argument\n        // (like an x when inside the expression of a function\n        // assignment `f(x) = ...`)\n        return function (scope, args, context) {\n          return args[name];\n        };\n      } else if (name in math) {\n        return function (scope, args, context) {\n          return scope.has(name) ? scope.get(name) : getSafeProperty(math, name);\n        };\n      } else {\n        var isUnit = isValuelessUnit(name);\n        return function (scope, args, context) {\n          return scope.has(name) ? scope.get(name) : isUnit ? new Unit(null, name) : SymbolNode.onUndefinedSymbol(name);\n        };\n      }\n    }\n\n    /**\n     * Execute a callback for each of the child nodes of this node\n     * @param {function(child: Node, path: string, parent: Node)} callback\n     */\n    forEach(callback) {\n      // nothing to do, we don't have any children\n    }\n\n    /**\n     * Create a new SymbolNode with children produced by the given callback.\n     * Trivial since a SymbolNode has no children\n     * @param {function(child: Node, path: string, parent: Node) : Node} callback\n     * @returns {SymbolNode} Returns a clone of the node\n     */\n    map(callback) {\n      return this.clone();\n    }\n\n    /**\n     * Throws an error 'Undefined symbol {name}'\n     * @param {string} name\n     */\n    static onUndefinedSymbol(name) {\n      throw new Error('Undefined symbol ' + name);\n    }\n\n    /**\n     * Create a clone of this node, a shallow copy\n     * @return {SymbolNode}\n     */\n    clone() {\n      return new SymbolNode(this.name);\n    }\n\n    /**\n     * Get string representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n    _toString(options) {\n      return this.name;\n    }\n\n    /**\n     * Get HTML representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n    toHTML(options) {\n      var name = escape(this.name);\n      if (name === 'true' || name === 'false') {\n        return '<span class=\"math-symbol math-boolean\">' + name + '</span>';\n      } else if (name === 'i') {\n        return '<span class=\"math-symbol math-imaginary-symbol\">' + name + '</span>';\n      } else if (name === 'Infinity') {\n        return '<span class=\"math-symbol math-infinity-symbol\">' + name + '</span>';\n      } else if (name === 'NaN') {\n        return '<span class=\"math-symbol math-nan-symbol\">' + name + '</span>';\n      } else if (name === 'null') {\n        return '<span class=\"math-symbol math-null-symbol\">' + name + '</span>';\n      } else if (name === 'undefined') {\n        return '<span class=\"math-symbol math-undefined-symbol\">' + name + '</span>';\n      }\n      return '<span class=\"math-symbol\">' + name + '</span>';\n    }\n\n    /**\n     * Get a JSON representation of the node\n     * @returns {Object}\n     */\n    toJSON() {\n      return {\n        mathjs: 'SymbolNode',\n        name: this.name\n      };\n    }\n\n    /**\n     * Instantiate a SymbolNode from its JSON representation\n     * @param {Object} json  An object structured like\n     *                       `{\"mathjs\": \"SymbolNode\", name: \"x\"}`,\n     *                       where mathjs is optional\n     * @returns {SymbolNode}\n     */\n    static fromJSON(json) {\n      return new SymbolNode(json.name);\n    }\n\n    /**\n     * Get LaTeX representation\n     * @param {Object} options\n     * @return {string} str\n     * @override\n     */\n    _toTex(options) {\n      var isUnit = false;\n      if (typeof math[this.name] === 'undefined' && isValuelessUnit(this.name)) {\n        isUnit = true;\n      }\n      var symbol = toSymbol(this.name, isUnit);\n      if (symbol[0] === '\\\\') {\n        // no space needed if the symbol starts with '\\'\n        return symbol;\n      }\n      // the space prevents symbols from breaking stuff like '\\cdot'\n      // if it's written right before the symbol\n      return ' ' + symbol;\n    }\n  }\n  return SymbolNode;\n}, {\n  isClass: true,\n  isNode: true\n});"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}